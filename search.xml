<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（二）]]></title>
    <url>%2F2019%2F09%2F04%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); AccountService accountService = (AccountService)applicationContext.getBean("accountService"); accountService.addAccountMoney("张三",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.test.AccountServiceImpl" scope="singleton"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean("accountService"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean("accountService"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+"执行了自定义的初始化方法"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+"执行了自定义的销毁方法"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="beanLife" class="com.test.BeanLife" init-method="initMyself" destroy-method="destroyMyself"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config.xml"); System.out.println("获得对象前"); BeanLife beanLife = (BeanLife)ctx.getBean("beanLife"); System.out.println("获得对象后"+beanLife); ctx.close(); &#125;&#125; 结果如下:]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next界面美化]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E7%9A%84next%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: "categories"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO搭建博客（搭建在github上面）]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name "nameVal" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（一）]]></title>
    <url>%2F2019%2F08%2F10%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 ​ 当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 ​ 当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 ​ 从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 ​ 综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念​ BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("绝对路径")); TestDao testDao = (TestDao)beanFactory.getBean("testDao"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext​ ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 ​ 创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：​ ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext("spring-config.xml"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：​ FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication("C:\Users\hp\IdeaProjects\my_pratices_account_day_01\src\main\resources\spring-config.xml"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器​ 在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println("Hello World"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;constructor-arg ref="testDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-config.xml"); TestService testService = (TestService)ac.getBean("testService"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;property name="testDao" ref="testDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
